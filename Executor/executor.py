from Helper import Level
from typing import Dict
from .executor_base import ExecutorBase
from Task import Task
from .enums import Status, Verdict
from tempfile import TemporaryDirectory
from math import floor


class Executor(ExecutorBase):
    def __init__(self, params: Dict, tempFolder: TemporaryDirectory = None):
        super().__init__(params, "Executor", tempFolder)

    def Run(self):
        from Experiment import Expander  # Delayed to avoid cyclic imports

        self.SetStarted()

        tasks = self.Configuration.RunTasks
        self.params['PreviousTaskLog'] = []
        self.params['Verdict'] = Verdict.NotSet
        for i, task in enumerate(tasks, start=1):
            if self.stopRequested:
                self.LogAndMessage(Level.INFO, "Received stop request, exiting")
                self.Status = Status.Cancelled
                self.params['Verdict'] = Verdict.Cancel
                break
            taskInstance: Task = task.Task(self.Log, self, Expander.ExpandDict(task.Params, self))
            self.AddMessage(f'Starting task {taskInstance.name}')

            try:
                taskInstance.Start()
            except Exception as e:
                self.params['Verdict'] = Verdict.Error
                raise e

            # Add the values generated by the task to the global dictionary
            self.params.update(taskInstance.Vault)
            self.params['PreviousTaskLog'] = taskInstance.LogMessages
            self.params['Verdict'] = Verdict.Max(self.Verdict, taskInstance.Verdict)

            self.AddMessage(f"Task '{taskInstance.name}' finished with verdict '{taskInstance.Verdict.name}'",
                            int(floor(10 + ((i / len(tasks)) * 90))))
        else:
            self.Status = Status.Finished

        self.SetFinished(percent=100)
